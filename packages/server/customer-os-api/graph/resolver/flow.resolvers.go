package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"github.com/99designs/gqlgen/graphql"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/dataloader"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/generated"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/graph/model"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/mapper"
	"github.com/openline-ai/openline-customer-os/packages/server/customer-os-api/tracing"
	commonModel "github.com/openline-ai/openline-customer-os/packages/server/customer-os-common-module/model"
	neo4jentity "github.com/openline-ai/openline-customer-os/packages/server/customer-os-neo4j-repository/entity"
	opentracing "github.com/opentracing/opentracing-go"
)

// Contacts is the resolver for the contacts field.
func (r *flowResolver) Contacts(ctx context.Context, obj *model.Flow) ([]*model.FlowContact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Contacts", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := dataloader.For(ctx).GetFlowContactsForFlow(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		graphql.AddErrorf(ctx, "Failed to get flow contacts")
		return nil, nil
	}
	return mapper.MapEntitiesToFlowContacts(entities), nil
}

// Senders is the resolver for the senders field.
func (r *flowResolver) Senders(ctx context.Context, obj *model.Flow) ([]*model.FlowSender, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Senders", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := dataloader.For(ctx).GetFlowSendersForFlow(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		graphql.AddErrorf(ctx, "Failed to get flow senders")
		return nil, nil
	}
	return mapper.MapEntitiesToFlowSenders(entities), nil
}

// Contact is the resolver for the contact field.
func (r *flowContactResolver) Contact(ctx context.Context, obj *model.FlowContact) (*model.Contact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Contact", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowParticipantById(ctx, obj.Metadata.ID)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	//TODO THIS IS NOT CORRECT
	contactEntity, err := r.Services.ContactService.GetById(ctx, entity.EntityId)
	if err != nil || contactEntity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	return mapper.MapEntityToContact(contactEntity), nil
}

// Flow is the resolver for the flow field.
func (r *flowSenderResolver) Flow(ctx context.Context, obj *model.FlowSender) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Flow", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := dataloader.For(ctx).GetFlowsWithSender(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		graphql.AddErrorf(ctx, "Failed to get flow sender users")
		return nil, nil
	}

	if entities == nil || len(*entities) == 0 {
		return nil, fmt.Errorf("Flow not found")
	}
	return mapper.MapEntitiesToFlows(entities)[0], nil
}

// User is the resolver for the user field.
func (r *flowSenderResolver) User(ctx context.Context, obj *model.FlowSender) (*model.User, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Contacts", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := dataloader.For(ctx).GetUserForFlowSenders(ctx, obj.Metadata.ID)
	if err != nil {
		tracing.TraceErr(opentracing.SpanFromContext(ctx), err)
		graphql.AddErrorf(ctx, "Failed to get flow sender users")
		return nil, nil
	}
	return mapper.MapEntityToUser(entities), nil
}

// FlowMerge is the resolver for the flow_Merge field.
func (r *mutationResolver) FlowMerge(ctx context.Context, input model.FlowMergeInput) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowMerge", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	flow, err := r.Services.CommonServices.FlowService.FlowMerge(ctx, nil, mapper.MapFlowMergeInputToEntity(input))
	if err != nil || flow == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	return mapper.MapEntityToFlow(flow), nil
}

// FlowChangeStatus is the resolver for the flow_changeStatus field.
func (r *mutationResolver) FlowChangeStatus(ctx context.Context, id string, status neo4jentity.FlowStatus) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowChangeStatus", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	e, err := r.Services.CommonServices.FlowService.FlowChangeStatus(ctx, id, status)
	if err != nil || e == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}

	//TODO this is correct and used in testing for email
	//tenant := common.GetTenantFromContext(ctx)
	//
	//t := true
	//
	//for i := 1; i <= 500; i++ {
	//	contactId, err := r.Services.ContactService.Create(ctx, &service.ContactCreateData{
	//		ContactEntity: &neo4jentity.ContactEntity{
	//			FirstName: "Test",
	//			LastName:  fmt.Sprintf("%d", i),
	//		},
	//		EmailEntity: &neo4jentity.EmailEntity{
	//			RawEmail: fmt.Sprintf("%d@test.com", i),
	//			Work:     &t,
	//		},
	//	})
	//
	//	if err != nil {
	//		tracing.TraceErr(span, err)
	//		graphql.AddErrorf(ctx, "")
	//		return nil, err
	//	}
	//
	//	_, err = r.Services.CommonServices.FlowService.FlowParticipantAdd(ctx, e.Id, contactId, commonModel.CONTACT)
	//	if err != nil {
	//		tracing.TraceErr(span, err)
	//		graphql.AddErrorf(ctx, "")
	//		return nil, err
	//	}
	//}
	//
	//userId := uuid.New().String()
	//err = r.Services.CommonServices.Neo4jRepositories.UserWriteRepository.CreateUser(ctx, neo4jentity.UserEntity{Id: userId})
	//
	//for i := 1; i <= 5; i++ {
	//	userEmail := fmt.Sprintf("mailbox%d@test.com%s", i, uuid.New().String())
	//	mailboxdId := uuid.New().String()
	//	r.Services.CommonServices.Neo4jRepositories.EmailWriteRepository.CreateEmail(ctx, tenant, mailboxdId, repository.EmailCreateFields{RawEmail: userEmail})
	//	r.Services.CommonServices.Neo4jRepositories.EmailWriteRepository.LinkWithUser(ctx, tenant, userId, mailboxdId, false)
	//	mailbox := entity.TenantSettingsMailbox{
	//		Tenant:          tenant,
	//		MailboxUsername: userEmail,
	//		Username:        userEmail,
	//	}
	//	r.Services.CommonServices.PostgresRepositories.TenantSettingsMailboxRepository.Merge(ctx, tenant, &mailbox)
	//	mailbox = entity.TenantSettingsMailbox{
	//		Tenant:                  tenant,
	//		MailboxUsername:         userEmail,
	//		Username:                userEmail,
	//		RampUpCurrent:           40,
	//		RampUpMax:               40,
	//		MinMinutesBetweenEmails: 10,
	//		MaxMinutesBetweenEmails: 10,
	//	}
	//	r.Services.CommonServices.PostgresRepositories.TenantSettingsMailboxRepository.Merge(ctx, tenant, &mailbox)
	//}
	//
	//r.FlowSenderMerge(ctx, e.Id, model.FlowSenderMergeInput{
	//	UserID: &userId,
	//})
	//
	//schedule1 := entity.UserWorkingSchedule{
	//	UserId:    userId,
	//	DayRange:  "Mon-Wed",
	//	StartHour: "08:30",
	//	EndHour:   "10:00",
	//}
	//err = r.Services.Repositories.PostgresRepositories.UserWorkingScheduleRepository.Store(ctx, tenant, &schedule1)
	//if err != nil {
	//	tracing.TraceErr(span, err)
	//	graphql.AddErrorf(ctx, "")
	//	return nil, err
	//}
	//
	//schedule2 := entity.UserWorkingSchedule{
	//	UserId:    userId,
	//	DayRange:  "Thu-Thu",
	//	StartHour: "10:00",
	//	EndHour:   "14:00",
	//}
	//err = r.Services.Repositories.PostgresRepositories.UserWorkingScheduleRepository.Store(ctx, tenant, &schedule2)
	//if err != nil {
	//	tracing.TraceErr(span, err)
	//	graphql.AddErrorf(ctx, "")
	//	return nil, err
	//}
	//
	//schedule3 := entity.UserWorkingSchedule{
	//	UserId:    userId,
	//	DayRange:  "Fri-Fri",
	//	StartHour: "16:00",
	//	EndHour:   "18:00",
	//}
	//err = r.Services.Repositories.PostgresRepositories.UserWorkingScheduleRepository.Store(ctx, tenant, &schedule3)
	//if err != nil {
	//	tracing.TraceErr(span, err)
	//	graphql.AddErrorf(ctx, "")
	//	return nil, err
	//}
	//
	//e, err = r.Services.CommonServices.FlowService.FlowChangeStatus(ctx, e.Id, neo4jentity.FlowStatusActive)
	//if err != nil {
	//	tracing.TraceErr(span, err)
	//	graphql.AddErrorf(ctx, "")
	//	return nil, err
	//}

	//TODO this is correct and used in testing sending linkedin connections
	//tenant := common.GetTenantFromContext(ctx)
	//
	//t := true
	//
	//for i := 1; i <= 100; i++ {
	//	contactId, err := r.Services.ContactService.Create(ctx, &service.ContactCreateData{
	//		ContactEntity: &neo4jentity.ContactEntity{
	//			FirstName: "Test",
	//			LastName:  fmt.Sprintf("%d", i),
	//		},
	//		EmailEntity: &neo4jentity.EmailEntity{
	//			RawEmail: fmt.Sprintf("%d@test.com", i),
	//			Work:     &t,
	//		},
	//		SocialUrl: fmt.Sprintf("https://www.linkedin.com/in/%d", i),
	//	})
	//
	//	if err != nil {
	//		tracing.TraceErr(span, err)
	//		graphql.AddErrorf(ctx, "")
	//		return nil, err
	//	}
	//
	//	_, err = r.Services.CommonServices.FlowService.FlowParticipantAdd(ctx, e.Id, contactId, commonModel.CONTACT)
	//	if err != nil {
	//		tracing.TraceErr(span, err)
	//		graphql.AddErrorf(ctx, "")
	//		return nil, err
	//	}
	//}
	//
	//for i := 1; i <= 2; i++ {
	//	userId := uuid.New().String()
	//	err = r.Services.CommonServices.Neo4jRepositories.UserWriteRepository.CreateUser(ctx, neo4jentity.UserEntity{Id: userId})
	//
	//	for i := 1; i <= 1; i++ {
	//		userEmail := fmt.Sprintf("mailbox%d@test.com%s", i, uuid.New().String())
	//		emailId := uuid.New().String()
	//		r.Services.CommonServices.Neo4jRepositories.EmailWriteRepository.CreateEmail(ctx, tenant, emailId, repository.EmailCreateFields{RawEmail: userEmail})
	//		r.Services.CommonServices.Neo4jRepositories.EmailWriteRepository.LinkWithUser(ctx, tenant, userId, emailId, true)
	//		r.Services.CommonServices.PostgresRepositories.BrowserConfigRepository.Merge(ctx, &entity.BrowserConfig{
	//			Tenant: tenant,
	//			UserId: userId,
	//			Status: "VALID",
	//		})
	//	}
	//
	//	r.FlowSenderMerge(ctx, e.Id, model.FlowSenderMergeInput{
	//		UserID: &userId,
	//	})
	//
	//	schedule3 := entity.UserWorkingSchedule{
	//		UserId:    userId,
	//		DayRange:  "Mon-Sun",
	//		StartHour: "08:00",
	//		EndHour:   "18:00",
	//	}
	//	err = r.Services.Repositories.PostgresRepositories.UserWorkingScheduleRepository.Store(ctx, tenant, &schedule3)
	//	if err != nil {
	//		tracing.TraceErr(span, err)
	//		graphql.AddErrorf(ctx, "")
	//		return nil, err
	//	}
	//}
	//
	//e, err = r.Services.CommonServices.FlowService.FlowChangeStatus(ctx, e.Id, neo4jentity.FlowStatusActive)
	//if err != nil {
	//	tracing.TraceErr(span, err)
	//	graphql.AddErrorf(ctx, "")
	//	return nil, err
	//}

	return mapper.MapEntityToFlow(e), nil
}

// FlowContactAdd is the resolver for the flowContact_Add field.
func (r *mutationResolver) FlowContactAdd(ctx context.Context, flowID string, contactID string) (*model.FlowContact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowParticipantAdd", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowParticipantAdd(ctx, flowID, contactID, commonModel.CONTACT)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlowContact(entity), nil
}

// FlowContactAddBulk is the resolver for the flowContact_AddBulk field.
func (r *mutationResolver) FlowContactAddBulk(ctx context.Context, flowID string, contactID []string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactAddBulk", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	for _, id := range contactID {
		entity, err := r.Services.CommonServices.FlowService.FlowParticipantAdd(ctx, flowID, id, commonModel.CONTACT)
		if err != nil || entity == nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "")
			return &model.Result{Result: false}, err
		}
	}
	return &model.Result{Result: true}, nil
}

// FlowContactDelete is the resolver for the flowContact_Delete field.
func (r *mutationResolver) FlowContactDelete(ctx context.Context, id string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowParticipantDelete", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	err := r.Services.CommonServices.FlowService.FlowParticipantDelete(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return &model.Result{Result: false}, err
	}
	return &model.Result{Result: true}, nil
}

// FlowContactDeleteBulk is the resolver for the flowContact_DeleteBulk field.
func (r *mutationResolver) FlowContactDeleteBulk(ctx context.Context, id []string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowContactDeleteBulk", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	for _, id := range id {
		err := r.Services.CommonServices.FlowService.FlowParticipantDelete(ctx, id)
		if err != nil {
			tracing.TraceErr(span, err)
			graphql.AddErrorf(ctx, "")
			return &model.Result{Result: false}, err
		}
	}
	return &model.Result{Result: true}, nil
}

// FlowSenderMerge is the resolver for the flowSender_Merge field.
func (r *mutationResolver) FlowSenderMerge(ctx context.Context, flowID string, input model.FlowSenderMergeInput) (*model.FlowSender, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowSenderMerge", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowSenderMerge(ctx, flowID, mapper.MapFlowActionMergeInputToEntity(input))
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlowSender(entity), nil
}

// FlowSenderDelete is the resolver for the flowSender_Delete field.
func (r *mutationResolver) FlowSenderDelete(ctx context.Context, id string) (*model.Result, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowSenderDelete", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	err := r.Services.CommonServices.FlowService.FlowSenderDelete(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return &model.Result{Result: false}, err
	}
	return &model.Result{Result: true}, nil
}

// Flow is the resolver for the flow field.
func (r *queryResolver) Flow(ctx context.Context, id string) (*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Flows", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowGetById(ctx, id)
	if err != nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlow(entity), nil
}

// Flows is the resolver for the flows field.
func (r *queryResolver) Flows(ctx context.Context) ([]*model.Flow, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.Flows", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entities, err := r.Services.CommonServices.FlowService.FlowGetList(ctx)
	if err != nil || entities == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntitiesToFlows(entities), nil
}

// FlowParticipant is the resolver for the flowParticipant field.
func (r *queryResolver) FlowParticipant(ctx context.Context, id string) (*model.FlowContact, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.FlowParticipant", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	entity, err := r.Services.CommonServices.FlowService.FlowParticipantById(ctx, id)
	if err != nil || entity == nil {
		tracing.TraceErr(span, err)
		graphql.AddErrorf(ctx, "")
		return nil, err
	}
	return mapper.MapEntityToFlowContact(entity), nil
}

// FlowEmailVariables is the resolver for the flow_emailVariables field.
func (r *queryResolver) FlowEmailVariables(ctx context.Context) ([]*model.EmailVariableEntity, error) {
	ctx, span := tracing.StartGraphQLTracerSpan(ctx, "FlowResolver.EmailVariables", graphql.GetOperationContext(ctx))
	defer span.Finish()
	tracing.SetDefaultResolverSpanTags(ctx, span)

	contactVariables := make([]model.EmailVariableName, 0)
	contactVariables = append(contactVariables, model.EmailVariableNameSenderFirstName)
	contactVariables = append(contactVariables, model.EmailVariableNameSenderLastName)
	contactVariables = append(contactVariables, model.EmailVariableNameContactFirstName)
	contactVariables = append(contactVariables, model.EmailVariableNameContactLastName)
	contactVariables = append(contactVariables, model.EmailVariableNameContactEmail)
	contactVariables = append(contactVariables, model.EmailVariableNameOrganizationName)

	emailVariables := make([]*model.EmailVariableEntity, 0)
	emailVariables = append(emailVariables, &model.EmailVariableEntity{
		Type:      model.EmailVariableEntityTypeContact,
		Variables: contactVariables,
	})

	return emailVariables, nil
}

// Flow returns generated.FlowResolver implementation.
func (r *Resolver) Flow() generated.FlowResolver { return &flowResolver{r} }

// FlowContact returns generated.FlowContactResolver implementation.
func (r *Resolver) FlowContact() generated.FlowContactResolver { return &flowContactResolver{r} }

// FlowSender returns generated.FlowSenderResolver implementation.
func (r *Resolver) FlowSender() generated.FlowSenderResolver { return &flowSenderResolver{r} }

type flowResolver struct{ *Resolver }
type flowContactResolver struct{ *Resolver }
type flowSenderResolver struct{ *Resolver }
